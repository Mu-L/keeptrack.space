import { hex2rgba, parseRgba } from '../src/engine/utils/rgba';
// Generated by CodiumAI

/*
 *Code Analysis
 *
 *Objective:
 *The objective of the hex2rgba function is to convert a hexadecimal color code to its equivalent RGBA color code.
 *
 *Inputs:
 *- hex: a string representing the hexadecimal color code to be converted.
 *
 *Flow:
 *- The function first checks if the input hex string is valid using a regular expression.
 *- If the hex string is valid, it is converted to an array of characters and padded if necessary.
 *- The padded hex string is then parsed to an integer using the base 16 (hexadecimal) representation.
 *- The red, green, and blue components of the color are extracted from the parsed integer using bit shifting and masking operations.
 *- The red, green, and blue components are then normalized to the range [0, 1].
 *- The function returns an array containing the normalized red, green, and blue components, as well as an alpha value of 1.
 *
 *Outputs:
 *- An array of four numbers representing the RGBA color code equivalent to the input hexadecimal color code.
 *
 *Additional aspects:
 *- The function throws an error if the input hex string is not valid.
 *- The function assumes that the input hex string represents a color in the sRGB color space.
 */

describe('hex2rgba_function', () => {
  // Tests that the function allows valid 3-digit hex codes
  it('test_invalid_3_digit_hex_code', () => {
    expect(hex2rgba('#fff')).toEqual([1, 1, 1, 1]);
    expect(hex2rgba('#000')).toEqual([0, 0, 0, 1]);
    expect(hex2rgba('#123')).toMatchSnapshot();
  });

  // Tests that the function correctly converts a valid 6-digit hex code to RGBA
  it('test_valid_6_digit_hex_code', () => {
    expect(hex2rgba('#ffffff')).toEqual([1, 1, 1, 1]);
    expect(hex2rgba('#000000')).toEqual([0, 0, 0, 1]);
    expect(hex2rgba('#123456')).toMatchSnapshot();
  });

  // Tests that the function correctly converts an uppercase hex code to RGBA
  it('test_uppercase_hex_code', () => {
    expect(hex2rgba('#ABCDEF')).toMatchSnapshot();
  });

  // Tests that the function correctly converts a lowercase hex code to RGBA
  it('test_lowercase_hex_code', () => {
    expect(hex2rgba('#abcdef')).toMatchSnapshot();
  });

  // Tests that the function throws an error when given an invalid hex code
  it('test_invalid_hex_code', () => {
    expect(() => hex2rgba('#12345')).toThrow('Invalid hex input');
  });

  // Tests that the function throws an error when given a hex code with invalid characters
  it('test_hex_code_with_invalid_characters', () => {
    expect(() => hex2rgba('#12G456')).toThrow('Invalid hex input');
  });
});

// Generated by CodiumAI

/*
 *Code Analysis
 *
 *Objective:
 *The objective of the parseRgba function is to parse a string in the format of rgba color and return an array of four numbers representing the red, green, blue, and alpha values
 *of the color.
 *
 *Inputs:
 *- str: a string in the format of rgba color (e.g. "rgba(255, 255, 255, 0.5)")
 *
 *Flow:
 *1. The function checks if the input string matches the regex pattern for rgba color.
 *2. If the input string is not valid, the function throws an error.
 *3. If the input string is valid, the function extracts the red, green, blue, and alpha values from the string using regex and stores them in an array of type rgbaType.
 *4. The function converts the red, green, and blue values from strings to numbers and divides them by 255 to get the values in the range of 0 to 1.
 *5. The function converts the alpha value from a string to a number and returns an array of four numbers representing the rgba color.
 *
 *Outputs:
 *- An array of four numbers representing the red, green, blue, and alpha values of the input rgba color.
 *
 *Additional aspects:
 *- The function uses regex to validate and extract the rgba values from the input string.
 *- The function divides the red, green, and blue values by 255 to get them in the range of 0 to 1.
 *- The function does not modify the input string.
 */

describe('parseRgba', () => {
  // Tests that the function can parse a valid rgba string input
  it('test_valid_rgba_string_input', () => {
    expect(parseRgba('rgba(255, 255, 255, 1)')).toEqual([1, 1, 1, 1]);
  });

  // Tests that the function can parse minimum rgba values
  it('test_minimum_rgba_values', () => {
    expect(parseRgba('rgba(0, 0, 0, 0)')).toEqual([0, 0, 0, 0]);
  });

  // Tests that the function can parse maximum rgba values
  it('test_maximum_rgba_values', () => {
    expect(parseRgba('rgba(255, 255, 255, 1)')).toEqual([1, 1, 1, 1]);
  });

  // Tests that the function throws an error when given an invalid rgba string input
  it('test_invalid_rgba_string_input', () => {
    expect(() => parseRgba('rgb(255, 255, 255)')).toThrowError('Invalid rgba input');
  });

  // Tests that the function throws an error when given negative rgba values
  it('test_negative_rgba_values', () => {
    expect(() => parseRgba('rgba(-1, 0, 0, 1)')).toThrowError('Invalid rgba input');
  });

  // Tests that the function throws an error when given rgba values greater than 255
  it('test_rgba_values_greater_than_255', () => {
    expect(() => parseRgba('rgba(256, 0, 0, 1)')).toThrowError('Invalid rgba input');
  });
});
